/**
 * Welcome to Cloudflare Workers!
 *
 * This is a template for a Scheduled Worker: a Worker that can run on a
 * configurable interval:
 * https://developers.cloudflare.com/workers/platform/triggers/cron-triggers/
 *
 * - Run `npm run dev` in your terminal to start a development server
 * - Open a browser tab at http://localhost:8787/ to see your worker in action
 * - Run `npm run deploy` to publish your worker
 *
 * Learn more at https://developers.cloudflare.com/workers/
 */

addEventListener('fetch', (event: FetchEvent) => {
	event.respondWith(fetch(event.request));
});

var botToken = '';
var chatId = '';
var urlToCheck = '';

function init(env: { BOT_TOKEN?: string; CHAT_ID?: string, URL_TO_CHECK?: string }) {
	botToken = env.BOT_TOKEN || ''; // Replace with your bot token
	chatId = env.CHAT_ID || ''; // Replace with your chat ID
}

async function sendAlertToTelegram(message: string) {
	if (!botToken || !chatId) {
		throw new Error('BOT_TOKEN and CHAT_ID environment variables must be set');
	}
	if (!message) {
		throw new Error('Message cannot be empty');
	}

	const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
	const payload = {
		chat_id: chatId,
		text: message,
	};

	const response = await fetch(telegramApiUrl, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify(payload),
	});

	if (!response.ok) {
		throw new Error(`Error sending message: ${response.statusText}`);
	}
}

async function sendMessageConditionally(url: string, success: boolean) {
	if (!url) {
		console.log('url is undefined');
		return;
	}
	if (success) {
		const msg = `${url} is responding successfully!`;
		await sendAlertToTelegram(msg);
	}
	else {
	  const msg = `${url} is not responding.`;
	  // if the current time is a multiple of 3 hours
	  if (new Date().getHours() % 3 === 0) {
	    await sendAlertToTelegram(msg);
	  } else {
	    console.log('not sending ' + msg);
	  }
	}
}

async function handleRequest(urlToCheck: string) {
	if (!urlToCheck) {
		console.log('url is undefined');
		return;
	}

	const controller = new AbortController();
	const timeout = setTimeout(() => {
		controller.abort();
	}, 1000);

	try {
		// await with timeout
		const response = await fetch(urlToCheck, { method: 'GET', signal: controller.signal });
		clearTimeout(timeout);
		// handle response...
		const status = response.status;

		if (status === 200) {
			await sendMessageConditionally(urlToCheck, true);
		} else {
			await sendMessageConditionally(urlToCheck, false);
		}

		return new Response('URL check complete', { status: 200 });
	} catch (err: unknown) {
		if (err instanceof Error) {
			if (err.name === 'AbortError') {
				console.log('Fetch timed out');
				await sendMessageConditionally(urlToCheck, false);
			} else {
				console.log('Some other error: ', err);
				// throw err;
			}
		}
	}
}

export default {
	// The scheduled handler is invoked at the interval set in our wrangler.toml's
	// [[triggers]] configuration.

	// A Cron Trigger can make requests to other endpoints on the Internet,
	// publish to a Queue, query a D1 Database, and much more.

	// We'll keep it simple and make an API call to a Cloudflare API:
	// let resp = await fetch('https://api.cloudflare.com/client/v4/ips');
	// let wasSuccessful = resp.ok ? 'success' : 'fail';

	async fetch(request: Request, env: { URL_TO_CHECK?: string }, ctx: any) {
		const html = `<!DOCTYPE html>
		<body>
		  <h1>Hello World</h1>
		  <p>This markup was generated by a Cloudflare Worker.</p>
		</body>`;

		return new Response(html, {
			headers: {
				'content-type': 'text/html;charset=UTF-8',
			},
		});
	},
	async scheduled(event: ScheduledEvent, env: { URL_TO_CHECK?: string }, ctx: any) {
		init(env);
		const urlToCheck = env.URL_TO_CHECK || '';

		await handleRequest(urlToCheck);

		// You could store this result in KV, write to a D1 Database, or publish to a Queue.
		// In this template, we'll just log the result:
		console.log(`trigger fired at ${event.cron}`);
	},
};
