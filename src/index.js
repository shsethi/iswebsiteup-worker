/**
 * Welcome to Cloudflare Workers!
 *
 * This is a template for a Scheduled Worker: a Worker that can run on a
 * configurable interval:
 * https://developers.cloudflare.com/workers/platform/triggers/cron-triggers/
 *
 * - Run `npm run dev` in your terminal to start a development server
 * - Open a browser tab at http://localhost:8787/ to see your worker in action
 * - Run `npm run deploy` to publish your worker
 *
 * Learn more at https://developers.cloudflare.com/workers/
 */

addEventListener('fetch', event => {
	event.respondWith(fetch(event.request))
})

export default {
	// The scheduled handler is invoked at the interval set in our wrangler.toml's
	// [[triggers]] configuration.

	// A Cron Trigger can make requests to other endpoints on the Internet,
	// publish to a Queue, query a D1 Database, and much more.

	// We'll keep it simple and make an API call to a Cloudflare API:
	// let resp = await fetch('https://api.cloudflare.com/client/v4/ips');
	// let wasSuccessful = resp.ok ? 'success' : 'fail';


	async fetch(request, env, ctx) {

		const html = `<!DOCTYPE html>
			<body>
			  <h1>Hello World</h1>
			  <p>This markup was generated by a Cloudflare Worker.</p>
			</body>`;
	
		return new Response(html, {
		  headers: {
			"content-type": "text/html;charset=UTF-8",
		  },
		});
	},
	async scheduled(event, env, ctx) {
		const botToken = env.BOT_TOKEN; // Replace with your bot token
		const chatId = env.CHAT_ID; // Replace with your chat ID
		const urlToCheck = env.URL_TO_CHECK;

		async function sendMessage(message) {
			const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
			const payload = {
				chat_id: chatId,
				text: message,
			};

			const response = await fetch(telegramApiUrl, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload),
			});

			if (!response.ok) {
				throw new Error(`Error sending message: ${response.statusText}`);
			}
		}

		async function handleRequest(urlToCheck) {
			const controller = new AbortController();
			const timeout = setTimeout(() => {
				controller.abort();
			}, 1000);

			try {
				// await with timeout
				const response = await fetch(urlToCheck, { method: 'GET', signal: controller.signal });
				clearTimeout(timeout);
				// handle response...
				const status = response.status;

				if (status === 200) {
					await sendMessage(`${urlToCheck} is responding successfully!`);
				} else {
					await sendFailuerMessage();
				}

				return new Response('URL check complete', { status: 200 });
			} catch (err) {
				if (err.name === 'AbortError') {
					console.log('Fetch timed out');
					await sendFailuerMessage(urlToCheck);
				} else {
					console.log('Some other error: ', err);
					// throw err;
				}
			}

			async function sendFailuerMessage(url) {
				const msg = `${url} is not responding.`;
				// if current time is multiple of 5
				if (new Date().getMinutes() % 5 === 0) {
					await sendMessage(msg);
				} else {
					console.log('not sending ' + msg);
				}
			}
		}

		await handleRequest(urlToCheck);

		// You could store this result in KV, write to a D1 Database, or publish to a Queue.
		// In this template, we'll just log the result:
		console.log(`trigger fired at ${event.cron}}`);
	},
};
